use ahash::AHashMap;
use feather_items::{Item, ItemStack};
use feather_loot_model as model;
use inlinable_string::InlinableString;
use model::{Entry, EntryKind, Function, FunctionKind, LootTableSet, Pool};
use once_cell::sync::Lazy;
use rand::Rng;
use smallvec::SmallVec;
use std::iter;
use thiserror::Error;

/// Implements sampling of loot tables.

/// The global loot table store, initialized at runtime from
/// the embedded loot table dump. (Generated by the build script)
static STORE: Lazy<AHashMap<InlinableString, LootTable>> = Lazy::new(|| {
    static BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/dump.json"));

    serde_json::from_slice::<LootTableSet>(BYTES)
        .expect("invalid loot table dump")
        .0
        .into_iter()
        .map(|(k, v)| (k, LootTable(v)))
        .collect()
});

/// Returns the loot table with the given ID, if it exists.
/// IDs are the same as those used in MC data packs. For example,
/// the loot table for stone blocks has ID "blocks/stone."
pub fn loot_table(id: &str) -> Option<&'static LootTable> {
    STORE.get(id)
}

/// Opaque wrapper over `model::LootTable`.
#[derive(Debug)]
pub struct LootTable(model::LootTable);

/// Error returned when a loot table sample fails.
#[derive(Debug, Error)]
pub enum SampleError {
    #[error("invalid item identifier {0}")]
    InvalidItem(String),
    #[error("missing loot table {0}")]
    MissingLootTable(String),
    /// Should be handled gracefully.
    #[error("dynamic loot table {0:?}")]
    IsDynamic(DynamicKind),
}

/// Indicates that the yielded item should
/// be computed based on a block entity.
#[derive(Debug)]
pub enum DynamicKind {
    /// Drop e.g. contents of chest
    Contents,
    /// Drop the block itself (e.g. player head, banner)
    This,
}

impl LootTable {
    /// Samples a value from the table.
    ///
    /// The returned set of item stacks is the result of sampling,
    /// i.e. the loot which should be yielded. May return multiple
    /// item stacks. No guarantee is made about the ordering
    /// or distinction of the returned vector.
    pub fn sample(&self, rng: &mut impl Rng) -> Result<SmallVec<[ItemStack; 2]>, SampleError> {
        let mut results = SmallVec::new();
        let pools = &self.0.pools;

        // Algorithm: sample each pool.
        // For each pool, evaluate `rolls` entries based on `Entry.weight`
        // and yield their results.
        for pool in pools {
            sample_pool(pool, rng, &mut results)?;
        }

        Ok(results)
    }
}

fn sample_pool(
    pool: &Pool,
    rng: &mut impl Rng,
    results: &mut SmallVec<[ItemStack; 2]>,
) -> Result<(), SampleError> {
    // `rolls` times, choose an entry at random based on weighting
    // and yield its results.

    // Only select from entries with their conditions satisfied
    // (TODO: conditions not yet implemented)

    let weight_sum = pool.entries.iter().map(|entry| entry.weight).sum::<u32>();
    for _ in 0..pool.rolls.sample(rng) {
        // We choose an integer at random from [0, weight_sum) and
        // determine which entry has a cumulative weight matching
        // the result. This algorithm is O(n) computaitonally, but this is unlikely
        // to matter in practice, because loot tables rarely
        // have more than one or two entries per pool.

        let n = rng.gen_range(0, weight_sum);
        let mut cumulative_weight = 0;
        let entry = pool
            .entries
            .iter()
            .find(|entry| {
                if n >= cumulative_weight && n < cumulative_weight + entry.weight {
                    true
                } else {
                    cumulative_weight += entry.weight;
                    false
                }
            })
            .expect("entry finding algorithm incorrect");

        sample_entry(entry, rng, results)?;
    }

    // apply functions to results
    results
        .iter_mut()
        .try_for_each(|item| apply_functions(pool.functions.iter(), item, rng))?;

    Ok(())
}

fn sample_entry(
    entry: &Entry,
    rng: &mut impl Rng,
    results: &mut SmallVec<[ItemStack; 2]>,
) -> Result<(), SampleError> {
    let mut single;
    let mut none = iter::empty();
    let mut sampled;

    let items: &mut dyn Iterator<Item = ItemStack> = match &entry.kind {
        EntryKind::Empty => &mut none,
        EntryKind::Item => {
            let item = Item::from_identifier(&entry.name)
                .ok_or_else(|| SampleError::InvalidItem(entry.name.to_string()))?;

            single = iter::once(ItemStack::new(item, 1));
            &mut single
        }
        EntryKind::Tag => &mut none, // TODO
        EntryKind::LootTable => {
            let table = loot_table(&entry.name)
                .ok_or_else(|| SampleError::MissingLootTable(entry.name.to_string()))?;

            sampled = table.sample(rng)?.into_iter();
            &mut sampled
        }
        EntryKind::Group | EntryKind::Sequence | EntryKind::Alternatives => {
            // Return an iterator over the child entries
            // (TODO: handle conditions properly)
            let mut temp = SmallVec::new();
            entry
                .children
                .iter()
                .try_for_each(|entry| sample_entry(entry, rng, &mut temp))?;
            sampled = temp.into_iter();
            &mut sampled
        }
        EntryKind::Dynamic => {
            let kind = if entry.name == "contents" || entry.name == "minecraft:contents" {
                DynamicKind::Contents
            } else {
                DynamicKind::This
            };

            return Err(SampleError::IsDynamic(kind));
        }
    };

    results.extend(
        items
            .map(|mut item| {
                apply_functions(entry.functions.iter(), &mut item, rng)?;
                Ok(item)
            })
            .filter_map(|item: Result<ItemStack, SampleError>| item.ok()),
    );

    Ok(())
}

fn apply_functions<'a>(
    functions: impl Iterator<Item = &'a Function>,
    item: &mut ItemStack,
    rng: &mut impl Rng,
) -> Result<(), SampleError> {
    for function in functions {
        match &function.kind {
            FunctionKind::SetCount { count } => {
                let count = count.sample(rng);
                item.amount = count as u8;
            }
            FunctionKind::Unknown => (),
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::mock::StepRng;

    #[test]
    fn store_deserializes_successfully() {
        Lazy::force(&STORE);
    }

    #[test]
    fn sample_dirt() {
        let table = loot_table("blocks/dirt").expect("missing loot table for dirt block");

        let mut rng = StepRng::new(0, 1);

        let items = table.sample(&mut rng).unwrap();

        assert_eq!(items.as_slice(), &[ItemStack::new(Item::Dirt, 1)]);
    }
}
